package model

// !!! DO NOT EDIT THIS FILE

import (
	"context"
	"encoding/json"
	"github.com/iancoleman/strcase"
	"github.com/mylxsw/eloquent/query"
	"gopkg.in/guregu/null.v3"
	"time"
)

func init() {

}

// RoomsN is a Rooms object, all fields are nullable
type RoomsN struct {
	original   *roomsOriginal
	roomsModel *RoomsModel

	Id             null.Int    `json:"id"`
	UserId         null.Int    `json:"user_id"`
	AvatarId       null.Int    `json:"avatar_id,omitempty"`
	AvatarUrl      null.String `json:"avatar_url,omitempty"`
	Name           null.String `json:"name,omitempty"`
	Description    null.String `json:"description,omitempty"`
	Priority       null.Int    `json:"priority,omitempty"`
	Model          null.String `json:"model,omitempty"`
	Vendor         null.String `json:"vendor,omitempty"`
	SystemPrompt   null.String `json:"system_prompt,omitempty"`
	MaxContext     null.Int    `json:"max_context,omitempty"`
	RoomType       null.Int    `json:"room_type,omitempty"`
	InitMessage    null.String `json:"init_message,omitempty"`
	LastActiveTime null.Time   `json:"last_active_time,omitempty"`
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// As convert object to other type
// dst must be a pointer to struct
func (inst *RoomsN) As(dst interface{}) error {
	return query.Copy(inst, dst)
}

// SetModel set model for Rooms
func (inst *RoomsN) SetModel(roomsModel *RoomsModel) {
	inst.roomsModel = roomsModel
}

// roomsOriginal is an object which stores original Rooms from database
type roomsOriginal struct {
	Id             null.Int
	UserId         null.Int
	AvatarId       null.Int
	AvatarUrl      null.String
	Name           null.String
	Description    null.String
	Priority       null.Int
	Model          null.String
	Vendor         null.String
	SystemPrompt   null.String
	MaxContext     null.Int
	RoomType       null.Int
	InitMessage    null.String
	LastActiveTime null.Time
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// Staled identify whether the object has been modified
func (inst *RoomsN) Staled(onlyFields ...string) bool {
	if inst.original == nil {
		inst.original = &roomsOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			return true
		}
		if inst.UserId != inst.original.UserId {
			return true
		}
		if inst.AvatarId != inst.original.AvatarId {
			return true
		}
		if inst.AvatarUrl != inst.original.AvatarUrl {
			return true
		}
		if inst.Name != inst.original.Name {
			return true
		}
		if inst.Description != inst.original.Description {
			return true
		}
		if inst.Priority != inst.original.Priority {
			return true
		}
		if inst.Model != inst.original.Model {
			return true
		}
		if inst.Vendor != inst.original.Vendor {
			return true
		}
		if inst.SystemPrompt != inst.original.SystemPrompt {
			return true
		}
		if inst.MaxContext != inst.original.MaxContext {
			return true
		}
		if inst.RoomType != inst.original.RoomType {
			return true
		}
		if inst.InitMessage != inst.original.InitMessage {
			return true
		}
		if inst.LastActiveTime != inst.original.LastActiveTime {
			return true
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			return true
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			return true
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					return true
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					return true
				}
			case "avatar_id":
				if inst.AvatarId != inst.original.AvatarId {
					return true
				}
			case "avatar_url":
				if inst.AvatarUrl != inst.original.AvatarUrl {
					return true
				}
			case "name":
				if inst.Name != inst.original.Name {
					return true
				}
			case "description":
				if inst.Description != inst.original.Description {
					return true
				}
			case "priority":
				if inst.Priority != inst.original.Priority {
					return true
				}
			case "model":
				if inst.Model != inst.original.Model {
					return true
				}
			case "vendor":
				if inst.Vendor != inst.original.Vendor {
					return true
				}
			case "system_prompt":
				if inst.SystemPrompt != inst.original.SystemPrompt {
					return true
				}
			case "max_context":
				if inst.MaxContext != inst.original.MaxContext {
					return true
				}
			case "room_type":
				if inst.RoomType != inst.original.RoomType {
					return true
				}
			case "init_message":
				if inst.InitMessage != inst.original.InitMessage {
					return true
				}
			case "last_active_time":
				if inst.LastActiveTime != inst.original.LastActiveTime {
					return true
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					return true
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					return true
				}
			default:
			}
		}
	}

	return false
}

// StaledKV return all fields has been modified
func (inst *RoomsN) StaledKV(onlyFields ...string) query.KV {
	kv := make(query.KV, 0)

	if inst.original == nil {
		inst.original = &roomsOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			kv["id"] = inst.Id
		}
		if inst.UserId != inst.original.UserId {
			kv["user_id"] = inst.UserId
		}
		if inst.AvatarId != inst.original.AvatarId {
			kv["avatar_id"] = inst.AvatarId
		}
		if inst.AvatarUrl != inst.original.AvatarUrl {
			kv["avatar_url"] = inst.AvatarUrl
		}
		if inst.Name != inst.original.Name {
			kv["name"] = inst.Name
		}
		if inst.Description != inst.original.Description {
			kv["description"] = inst.Description
		}
		if inst.Priority != inst.original.Priority {
			kv["priority"] = inst.Priority
		}
		if inst.Model != inst.original.Model {
			kv["model"] = inst.Model
		}
		if inst.Vendor != inst.original.Vendor {
			kv["vendor"] = inst.Vendor
		}
		if inst.SystemPrompt != inst.original.SystemPrompt {
			kv["system_prompt"] = inst.SystemPrompt
		}
		if inst.MaxContext != inst.original.MaxContext {
			kv["max_context"] = inst.MaxContext
		}
		if inst.RoomType != inst.original.RoomType {
			kv["room_type"] = inst.RoomType
		}
		if inst.InitMessage != inst.original.InitMessage {
			kv["init_message"] = inst.InitMessage
		}
		if inst.LastActiveTime != inst.original.LastActiveTime {
			kv["last_active_time"] = inst.LastActiveTime
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			kv["created_at"] = inst.CreatedAt
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			kv["updated_at"] = inst.UpdatedAt
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					kv["id"] = inst.Id
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					kv["user_id"] = inst.UserId
				}
			case "avatar_id":
				if inst.AvatarId != inst.original.AvatarId {
					kv["avatar_id"] = inst.AvatarId
				}
			case "avatar_url":
				if inst.AvatarUrl != inst.original.AvatarUrl {
					kv["avatar_url"] = inst.AvatarUrl
				}
			case "name":
				if inst.Name != inst.original.Name {
					kv["name"] = inst.Name
				}
			case "description":
				if inst.Description != inst.original.Description {
					kv["description"] = inst.Description
				}
			case "priority":
				if inst.Priority != inst.original.Priority {
					kv["priority"] = inst.Priority
				}
			case "model":
				if inst.Model != inst.original.Model {
					kv["model"] = inst.Model
				}
			case "vendor":
				if inst.Vendor != inst.original.Vendor {
					kv["vendor"] = inst.Vendor
				}
			case "system_prompt":
				if inst.SystemPrompt != inst.original.SystemPrompt {
					kv["system_prompt"] = inst.SystemPrompt
				}
			case "max_context":
				if inst.MaxContext != inst.original.MaxContext {
					kv["max_context"] = inst.MaxContext
				}
			case "room_type":
				if inst.RoomType != inst.original.RoomType {
					kv["room_type"] = inst.RoomType
				}
			case "init_message":
				if inst.InitMessage != inst.original.InitMessage {
					kv["init_message"] = inst.InitMessage
				}
			case "last_active_time":
				if inst.LastActiveTime != inst.original.LastActiveTime {
					kv["last_active_time"] = inst.LastActiveTime
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					kv["created_at"] = inst.CreatedAt
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					kv["updated_at"] = inst.UpdatedAt
				}
			default:
			}
		}
	}

	return kv
}

// Save create a new model or update it
func (inst *RoomsN) Save(ctx context.Context, onlyFields ...string) error {
	if inst.roomsModel == nil {
		return query.ErrModelNotSet
	}

	id, _, err := inst.roomsModel.SaveOrUpdate(ctx, *inst, onlyFields...)
	if err != nil {
		return err
	}

	inst.Id = null.IntFrom(id)
	return nil
}

// Delete remove a rooms
func (inst *RoomsN) Delete(ctx context.Context) error {
	if inst.roomsModel == nil {
		return query.ErrModelNotSet
	}

	_, err := inst.roomsModel.DeleteById(ctx, inst.Id.Int64)
	if err != nil {
		return err
	}

	return nil
}

// String convert instance to json string
func (inst *RoomsN) String() string {
	rs, _ := json.Marshal(inst)
	return string(rs)
}

type roomsScope struct {
	name  string
	apply func(builder query.Condition)
}

var roomsGlobalScopes = make([]roomsScope, 0)
var roomsLocalScopes = make([]roomsScope, 0)

// AddGlobalScopeForRooms assign a global scope to a model
func AddGlobalScopeForRooms(name string, apply func(builder query.Condition)) {
	roomsGlobalScopes = append(roomsGlobalScopes, roomsScope{name: name, apply: apply})
}

// AddLocalScopeForRooms assign a local scope to a model
func AddLocalScopeForRooms(name string, apply func(builder query.Condition)) {
	roomsLocalScopes = append(roomsLocalScopes, roomsScope{name: name, apply: apply})
}

func (m *RoomsModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range roomsGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range roomsLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *RoomsModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *RoomsModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}

	return true
}

type Rooms struct {
	Id             int64     `json:"id"`
	UserId         int64     `json:"user_id"`
	AvatarId       int64     `json:"avatar_id,omitempty"`
	AvatarUrl      string    `json:"avatar_url,omitempty"`
	Name           string    `json:"name,omitempty"`
	Description    string    `json:"description,omitempty"`
	Priority       int64     `json:"priority,omitempty"`
	Model          string    `json:"model,omitempty"`
	Vendor         string    `json:"vendor,omitempty"`
	SystemPrompt   string    `json:"system_prompt,omitempty"`
	MaxContext     int64     `json:"max_context,omitempty"`
	RoomType       int64     `json:"room_type,omitempty"`
	InitMessage    string    `json:"init_message,omitempty"`
	LastActiveTime time.Time `json:"last_active_time,omitempty"`
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (w Rooms) ToRoomsN(allows ...string) RoomsN {
	if len(allows) == 0 {
		return RoomsN{

			Id:             null.IntFrom(int64(w.Id)),
			UserId:         null.IntFrom(int64(w.UserId)),
			AvatarId:       null.IntFrom(int64(w.AvatarId)),
			AvatarUrl:      null.StringFrom(w.AvatarUrl),
			Name:           null.StringFrom(w.Name),
			Description:    null.StringFrom(w.Description),
			Priority:       null.IntFrom(int64(w.Priority)),
			Model:          null.StringFrom(w.Model),
			Vendor:         null.StringFrom(w.Vendor),
			SystemPrompt:   null.StringFrom(w.SystemPrompt),
			MaxContext:     null.IntFrom(int64(w.MaxContext)),
			RoomType:       null.IntFrom(int64(w.RoomType)),
			InitMessage:    null.StringFrom(w.InitMessage),
			LastActiveTime: null.TimeFrom(w.LastActiveTime),
			CreatedAt:      null.TimeFrom(w.CreatedAt),
			UpdatedAt:      null.TimeFrom(w.UpdatedAt),
		}
	}

	res := RoomsN{}
	for _, al := range allows {
		switch strcase.ToSnake(al) {

		case "id":
			res.Id = null.IntFrom(int64(w.Id))
		case "user_id":
			res.UserId = null.IntFrom(int64(w.UserId))
		case "avatar_id":
			res.AvatarId = null.IntFrom(int64(w.AvatarId))
		case "avatar_url":
			res.AvatarUrl = null.StringFrom(w.AvatarUrl)
		case "name":
			res.Name = null.StringFrom(w.Name)
		case "description":
			res.Description = null.StringFrom(w.Description)
		case "priority":
			res.Priority = null.IntFrom(int64(w.Priority))
		case "model":
			res.Model = null.StringFrom(w.Model)
		case "vendor":
			res.Vendor = null.StringFrom(w.Vendor)
		case "system_prompt":
			res.SystemPrompt = null.StringFrom(w.SystemPrompt)
		case "max_context":
			res.MaxContext = null.IntFrom(int64(w.MaxContext))
		case "room_type":
			res.RoomType = null.IntFrom(int64(w.RoomType))
		case "init_message":
			res.InitMessage = null.StringFrom(w.InitMessage)
		case "last_active_time":
			res.LastActiveTime = null.TimeFrom(w.LastActiveTime)
		case "created_at":
			res.CreatedAt = null.TimeFrom(w.CreatedAt)
		case "updated_at":
			res.UpdatedAt = null.TimeFrom(w.UpdatedAt)
		default:
		}
	}

	return res
}

// As convert object to other type
// dst must be a pointer to struct
func (w Rooms) As(dst interface{}) error {
	return query.Copy(w, dst)
}

func (w *RoomsN) ToRooms() Rooms {
	return Rooms{

		Id:             w.Id.Int64,
		UserId:         w.UserId.Int64,
		AvatarId:       w.AvatarId.Int64,
		AvatarUrl:      w.AvatarUrl.String,
		Name:           w.Name.String,
		Description:    w.Description.String,
		Priority:       w.Priority.Int64,
		Model:          w.Model.String,
		Vendor:         w.Vendor.String,
		SystemPrompt:   w.SystemPrompt.String,
		MaxContext:     w.MaxContext.Int64,
		RoomType:       w.RoomType.Int64,
		InitMessage:    w.InitMessage.String,
		LastActiveTime: w.LastActiveTime.Time,
		CreatedAt:      w.CreatedAt.Time,
		UpdatedAt:      w.UpdatedAt.Time,
	}
}

// RoomsModel is a model which encapsulates the operations of the object
type RoomsModel struct {
	db        *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes  []string

	query query.SQLBuilder
}

var roomsTableName = "rooms"

// RoomsTable return table name for Rooms
func RoomsTable() string {
	return roomsTableName
}

const (
	FieldRoomsId             = "id"
	FieldRoomsUserId         = "user_id"
	FieldRoomsAvatarId       = "avatar_id"
	FieldRoomsAvatarUrl      = "avatar_url"
	FieldRoomsName           = "name"
	FieldRoomsDescription    = "description"
	FieldRoomsPriority       = "priority"
	FieldRoomsModel          = "model"
	FieldRoomsVendor         = "vendor"
	FieldRoomsSystemPrompt   = "system_prompt"
	FieldRoomsMaxContext     = "max_context"
	FieldRoomsRoomType       = "room_type"
	FieldRoomsInitMessage    = "init_message"
	FieldRoomsLastActiveTime = "last_active_time"
	FieldRoomsCreatedAt      = "created_at"
	FieldRoomsUpdatedAt      = "updated_at"
)

// RoomsFields return all fields in Rooms model
func RoomsFields() []string {
	return []string{
		"id",
		"user_id",
		"avatar_id",
		"avatar_url",
		"name",
		"description",
		"priority",
		"model",
		"vendor",
		"system_prompt",
		"max_context",
		"room_type",
		"init_message",
		"last_active_time",
		"created_at",
		"updated_at",
	}
}

func SetRoomsTable(tableName string) {
	roomsTableName = tableName
}

// NewRoomsModel create a RoomsModel
func NewRoomsModel(db query.Database) *RoomsModel {
	return &RoomsModel{
		db:                  query.NewDatabaseWrap(db),
		tableName:           roomsTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes:  make([]string, 0),
		query:               query.Builder(),
	}
}

// GetDB return database instance
func (m *RoomsModel) GetDB() query.Database {
	return m.db.GetDB()
}

func (m *RoomsModel) clone() *RoomsModel {
	return &RoomsModel{
		db:                  m.db,
		tableName:           m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes:  append([]string{}, m.includeLocalScopes...),
		query:               m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *RoomsModel) WithoutGlobalScopes(names ...string) *RoomsModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *RoomsModel) WithLocalScopes(names ...string) *RoomsModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Condition add query builder to model
func (m *RoomsModel) Condition(builder query.SQLBuilder) *RoomsModel {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *RoomsModel) Find(ctx context.Context, id int64) (*RoomsN, error) {
	return m.First(ctx, m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *RoomsModel) Exists(ctx context.Context, builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(ctx, builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *RoomsModel) Count(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *RoomsModel) Paginate(ctx context.Context, page int64, perPage int64, builders ...query.SQLBuilder) ([]RoomsN, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta{
		PerPage: perPage,
		Page:    page,
	}

	count, err := m.Count(ctx, builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count%perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(ctx, append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *RoomsModel) Get(ctx context.Context, builders ...query.SQLBuilder) ([]RoomsN, error) {
	b := m.query.Merge(builders...).Table(m.tableName).AppendCondition(m.applyScope())
	if len(b.GetFields()) == 0 {
		b = b.Select(
			"id",
			"user_id",
			"avatar_id",
			"avatar_url",
			"name",
			"description",
			"priority",
			"model",
			"vendor",
			"system_prompt",
			"max_context",
			"room_type",
			"init_message",
			"last_active_time",
			"created_at",
			"updated_at",
		)
	}

	fields := b.GetFields()
	selectFields := make([]query.Expr, 0)

	for _, f := range fields {
		switch strcase.ToSnake(f.Value) {

		case "id":
			selectFields = append(selectFields, f)
		case "user_id":
			selectFields = append(selectFields, f)
		case "avatar_id":
			selectFields = append(selectFields, f)
		case "avatar_url":
			selectFields = append(selectFields, f)
		case "name":
			selectFields = append(selectFields, f)
		case "description":
			selectFields = append(selectFields, f)
		case "priority":
			selectFields = append(selectFields, f)
		case "model":
			selectFields = append(selectFields, f)
		case "vendor":
			selectFields = append(selectFields, f)
		case "system_prompt":
			selectFields = append(selectFields, f)
		case "max_context":
			selectFields = append(selectFields, f)
		case "room_type":
			selectFields = append(selectFields, f)
		case "init_message":
			selectFields = append(selectFields, f)
		case "last_active_time":
			selectFields = append(selectFields, f)
		case "created_at":
			selectFields = append(selectFields, f)
		case "updated_at":
			selectFields = append(selectFields, f)
		}
	}

	var createScanVar = func(fields []query.Expr) (*RoomsN, []interface{}) {
		var roomsVar RoomsN
		scanFields := make([]interface{}, 0)

		for _, f := range fields {
			switch strcase.ToSnake(f.Value) {

			case "id":
				scanFields = append(scanFields, &roomsVar.Id)
			case "user_id":
				scanFields = append(scanFields, &roomsVar.UserId)
			case "avatar_id":
				scanFields = append(scanFields, &roomsVar.AvatarId)
			case "avatar_url":
				scanFields = append(scanFields, &roomsVar.AvatarUrl)
			case "name":
				scanFields = append(scanFields, &roomsVar.Name)
			case "description":
				scanFields = append(scanFields, &roomsVar.Description)
			case "priority":
				scanFields = append(scanFields, &roomsVar.Priority)
			case "model":
				scanFields = append(scanFields, &roomsVar.Model)
			case "vendor":
				scanFields = append(scanFields, &roomsVar.Vendor)
			case "system_prompt":
				scanFields = append(scanFields, &roomsVar.SystemPrompt)
			case "max_context":
				scanFields = append(scanFields, &roomsVar.MaxContext)
			case "room_type":
				scanFields = append(scanFields, &roomsVar.RoomType)
			case "init_message":
				scanFields = append(scanFields, &roomsVar.InitMessage)
			case "last_active_time":
				scanFields = append(scanFields, &roomsVar.LastActiveTime)
			case "created_at":
				scanFields = append(scanFields, &roomsVar.CreatedAt)
			case "updated_at":
				scanFields = append(scanFields, &roomsVar.UpdatedAt)
			}
		}

		return &roomsVar, scanFields
	}

	sqlStr, params := b.Fields(selectFields...).ResolveQuery()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	roomss := make([]RoomsN, 0)
	for rows.Next() {
		roomsReal, scanFields := createScanVar(fields)
		if err := rows.Scan(scanFields...); err != nil {
			return nil, err
		}

		roomsReal.original = &roomsOriginal{}
		_ = query.Copy(roomsReal, roomsReal.original)

		roomsReal.SetModel(m)
		roomss = append(roomss, *roomsReal)
	}

	return roomss, nil
}

// First return first result for given query
func (m *RoomsModel) First(ctx context.Context, builders ...query.SQLBuilder) (*RoomsN, error) {
	res, err := m.Get(ctx, append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, query.ErrNoResult
	}

	return &res[0], nil
}

// Create save a new rooms to database
func (m *RoomsModel) Create(ctx context.Context, kv query.KV) (int64, error) {

	if _, ok := kv["created_at"]; !ok {
		kv["created_at"] = time.Now()
	}

	if _, ok := kv["updated_at"]; !ok {
		kv["updated_at"] = time.Now()
	}

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all roomss to database
func (m *RoomsModel) SaveAll(ctx context.Context, roomss []RoomsN) ([]int64, error) {
	ids := make([]int64, 0)
	for _, rooms := range roomss {
		id, err := m.Save(ctx, rooms)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a rooms to database
func (m *RoomsModel) Save(ctx context.Context, rooms RoomsN, onlyFields ...string) (int64, error) {
	return m.Create(ctx, rooms.StaledKV(onlyFields...))
}

// SaveOrUpdate save a new rooms or update it when it has a id > 0
func (m *RoomsModel) SaveOrUpdate(ctx context.Context, rooms RoomsN, onlyFields ...string) (id int64, updated bool, err error) {
	if rooms.Id.Int64 > 0 {
		_, _err := m.UpdateById(ctx, rooms.Id.Int64, rooms, onlyFields...)
		return rooms.Id.Int64, true, _err
	}

	_id, _err := m.Save(ctx, rooms, onlyFields...)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *RoomsModel) UpdateFields(ctx context.Context, kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	kv["updated_at"] = time.Now()

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *RoomsModel) Update(ctx context.Context, builder query.SQLBuilder, rooms RoomsN, onlyFields ...string) (int64, error) {
	return m.UpdateFields(ctx, rooms.StaledKV(onlyFields...), builder)
}

// UpdateById update a model by id
func (m *RoomsModel) UpdateById(ctx context.Context, id int64, rooms RoomsN, onlyFields ...string) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).UpdateFields(ctx, rooms.StaledKV(onlyFields...))
}

// Delete remove a model
func (m *RoomsModel) Delete(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()

}

// DeleteById remove a model by id
func (m *RoomsModel) DeleteById(ctx context.Context, id int64) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).Delete(ctx)
}
