package model

// !!! DO NOT EDIT THIS FILE

import (
	"context"
	"encoding/json"
	"github.com/iancoleman/strcase"
	"github.com/mylxsw/eloquent/query"
	"gopkg.in/guregu/null.v3"
	"time"
)

func init() {

}

// AlipayHistoryN is a AlipayHistory object, all fields are nullable
type AlipayHistoryN struct {
	original           *alipayHistoryOriginal
	alipayHistoryModel *AlipayHistoryModel

	Id             null.Int    `json:"id"`
	UserId         null.Int    `json:"user_id,omitempty"`
	PaymentId      null.String `json:"payment_id,omitempty"`
	ProductId      null.String `json:"product_id,omitempty"`
	BuyerId        null.String `json:"buyer_id,omitempty"`
	InvoiceAmount  null.Int    `json:"invoice_amount,omitempty"`
	ReceiptAmount  null.Int    `json:"receipt_amount,omitempty"`
	BuyerPayAmount null.Int    `json:"buyer_pay_amount,omitempty"`
	TotalAmount    null.Int    `json:"total_amount,omitempty"`
	PointAmount    null.Int    `json:"point_amount,omitempty"`
	TradeNo        null.String `json:"trade_no,omitempty"`
	BuyerLogonId   null.String `json:"buyer_logon_id,omitempty"`
	Status         null.Int    `json:"status,omitempty"`
	PurchaseAt     null.Time   `json:"purchase_at"`
	Note           null.String `json:"note"`
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// As convert object to other type
// dst must be a pointer to struct
func (inst *AlipayHistoryN) As(dst interface{}) error {
	return query.Copy(inst, dst)
}

// SetModel set model for AlipayHistory
func (inst *AlipayHistoryN) SetModel(alipayHistoryModel *AlipayHistoryModel) {
	inst.alipayHistoryModel = alipayHistoryModel
}

// alipayHistoryOriginal is an object which stores original AlipayHistory from database
type alipayHistoryOriginal struct {
	Id             null.Int
	UserId         null.Int
	PaymentId      null.String
	ProductId      null.String
	BuyerId        null.String
	InvoiceAmount  null.Int
	ReceiptAmount  null.Int
	BuyerPayAmount null.Int
	TotalAmount    null.Int
	PointAmount    null.Int
	TradeNo        null.String
	BuyerLogonId   null.String
	Status         null.Int
	PurchaseAt     null.Time
	Note           null.String
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// Staled identify whether the object has been modified
func (inst *AlipayHistoryN) Staled(onlyFields ...string) bool {
	if inst.original == nil {
		inst.original = &alipayHistoryOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			return true
		}
		if inst.UserId != inst.original.UserId {
			return true
		}
		if inst.PaymentId != inst.original.PaymentId {
			return true
		}
		if inst.ProductId != inst.original.ProductId {
			return true
		}
		if inst.BuyerId != inst.original.BuyerId {
			return true
		}
		if inst.InvoiceAmount != inst.original.InvoiceAmount {
			return true
		}
		if inst.ReceiptAmount != inst.original.ReceiptAmount {
			return true
		}
		if inst.BuyerPayAmount != inst.original.BuyerPayAmount {
			return true
		}
		if inst.TotalAmount != inst.original.TotalAmount {
			return true
		}
		if inst.PointAmount != inst.original.PointAmount {
			return true
		}
		if inst.TradeNo != inst.original.TradeNo {
			return true
		}
		if inst.BuyerLogonId != inst.original.BuyerLogonId {
			return true
		}
		if inst.Status != inst.original.Status {
			return true
		}
		if inst.PurchaseAt != inst.original.PurchaseAt {
			return true
		}
		if inst.Note != inst.original.Note {
			return true
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			return true
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			return true
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					return true
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					return true
				}
			case "payment_id":
				if inst.PaymentId != inst.original.PaymentId {
					return true
				}
			case "product_id":
				if inst.ProductId != inst.original.ProductId {
					return true
				}
			case "buyer_id":
				if inst.BuyerId != inst.original.BuyerId {
					return true
				}
			case "invoice_amount":
				if inst.InvoiceAmount != inst.original.InvoiceAmount {
					return true
				}
			case "receipt_amount":
				if inst.ReceiptAmount != inst.original.ReceiptAmount {
					return true
				}
			case "buyer_pay_amount":
				if inst.BuyerPayAmount != inst.original.BuyerPayAmount {
					return true
				}
			case "total_amount":
				if inst.TotalAmount != inst.original.TotalAmount {
					return true
				}
			case "point_amount":
				if inst.PointAmount != inst.original.PointAmount {
					return true
				}
			case "trade_no":
				if inst.TradeNo != inst.original.TradeNo {
					return true
				}
			case "buyer_logon_id":
				if inst.BuyerLogonId != inst.original.BuyerLogonId {
					return true
				}
			case "status":
				if inst.Status != inst.original.Status {
					return true
				}
			case "purchase_at":
				if inst.PurchaseAt != inst.original.PurchaseAt {
					return true
				}
			case "note":
				if inst.Note != inst.original.Note {
					return true
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					return true
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					return true
				}
			default:
			}
		}
	}

	return false
}

// StaledKV return all fields has been modified
func (inst *AlipayHistoryN) StaledKV(onlyFields ...string) query.KV {
	kv := make(query.KV, 0)

	if inst.original == nil {
		inst.original = &alipayHistoryOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			kv["id"] = inst.Id
		}
		if inst.UserId != inst.original.UserId {
			kv["user_id"] = inst.UserId
		}
		if inst.PaymentId != inst.original.PaymentId {
			kv["payment_id"] = inst.PaymentId
		}
		if inst.ProductId != inst.original.ProductId {
			kv["product_id"] = inst.ProductId
		}
		if inst.BuyerId != inst.original.BuyerId {
			kv["buyer_id"] = inst.BuyerId
		}
		if inst.InvoiceAmount != inst.original.InvoiceAmount {
			kv["invoice_amount"] = inst.InvoiceAmount
		}
		if inst.ReceiptAmount != inst.original.ReceiptAmount {
			kv["receipt_amount"] = inst.ReceiptAmount
		}
		if inst.BuyerPayAmount != inst.original.BuyerPayAmount {
			kv["buyer_pay_amount"] = inst.BuyerPayAmount
		}
		if inst.TotalAmount != inst.original.TotalAmount {
			kv["total_amount"] = inst.TotalAmount
		}
		if inst.PointAmount != inst.original.PointAmount {
			kv["point_amount"] = inst.PointAmount
		}
		if inst.TradeNo != inst.original.TradeNo {
			kv["trade_no"] = inst.TradeNo
		}
		if inst.BuyerLogonId != inst.original.BuyerLogonId {
			kv["buyer_logon_id"] = inst.BuyerLogonId
		}
		if inst.Status != inst.original.Status {
			kv["status"] = inst.Status
		}
		if inst.PurchaseAt != inst.original.PurchaseAt {
			kv["purchase_at"] = inst.PurchaseAt
		}
		if inst.Note != inst.original.Note {
			kv["note"] = inst.Note
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			kv["created_at"] = inst.CreatedAt
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			kv["updated_at"] = inst.UpdatedAt
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					kv["id"] = inst.Id
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					kv["user_id"] = inst.UserId
				}
			case "payment_id":
				if inst.PaymentId != inst.original.PaymentId {
					kv["payment_id"] = inst.PaymentId
				}
			case "product_id":
				if inst.ProductId != inst.original.ProductId {
					kv["product_id"] = inst.ProductId
				}
			case "buyer_id":
				if inst.BuyerId != inst.original.BuyerId {
					kv["buyer_id"] = inst.BuyerId
				}
			case "invoice_amount":
				if inst.InvoiceAmount != inst.original.InvoiceAmount {
					kv["invoice_amount"] = inst.InvoiceAmount
				}
			case "receipt_amount":
				if inst.ReceiptAmount != inst.original.ReceiptAmount {
					kv["receipt_amount"] = inst.ReceiptAmount
				}
			case "buyer_pay_amount":
				if inst.BuyerPayAmount != inst.original.BuyerPayAmount {
					kv["buyer_pay_amount"] = inst.BuyerPayAmount
				}
			case "total_amount":
				if inst.TotalAmount != inst.original.TotalAmount {
					kv["total_amount"] = inst.TotalAmount
				}
			case "point_amount":
				if inst.PointAmount != inst.original.PointAmount {
					kv["point_amount"] = inst.PointAmount
				}
			case "trade_no":
				if inst.TradeNo != inst.original.TradeNo {
					kv["trade_no"] = inst.TradeNo
				}
			case "buyer_logon_id":
				if inst.BuyerLogonId != inst.original.BuyerLogonId {
					kv["buyer_logon_id"] = inst.BuyerLogonId
				}
			case "status":
				if inst.Status != inst.original.Status {
					kv["status"] = inst.Status
				}
			case "purchase_at":
				if inst.PurchaseAt != inst.original.PurchaseAt {
					kv["purchase_at"] = inst.PurchaseAt
				}
			case "note":
				if inst.Note != inst.original.Note {
					kv["note"] = inst.Note
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					kv["created_at"] = inst.CreatedAt
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					kv["updated_at"] = inst.UpdatedAt
				}
			default:
			}
		}
	}

	return kv
}

// Save create a new model or update it
func (inst *AlipayHistoryN) Save(ctx context.Context, onlyFields ...string) error {
	if inst.alipayHistoryModel == nil {
		return query.ErrModelNotSet
	}

	id, _, err := inst.alipayHistoryModel.SaveOrUpdate(ctx, *inst, onlyFields...)
	if err != nil {
		return err
	}

	inst.Id = null.IntFrom(id)
	return nil
}

// Delete remove a alipay_history
func (inst *AlipayHistoryN) Delete(ctx context.Context) error {
	if inst.alipayHistoryModel == nil {
		return query.ErrModelNotSet
	}

	_, err := inst.alipayHistoryModel.DeleteById(ctx, inst.Id.Int64)
	if err != nil {
		return err
	}

	return nil
}

// String convert instance to json string
func (inst *AlipayHistoryN) String() string {
	rs, _ := json.Marshal(inst)
	return string(rs)
}

type alipayHistoryScope struct {
	name  string
	apply func(builder query.Condition)
}

var alipayHistoryGlobalScopes = make([]alipayHistoryScope, 0)
var alipayHistoryLocalScopes = make([]alipayHistoryScope, 0)

// AddGlobalScopeForAlipayHistory assign a global scope to a model
func AddGlobalScopeForAlipayHistory(name string, apply func(builder query.Condition)) {
	alipayHistoryGlobalScopes = append(alipayHistoryGlobalScopes, alipayHistoryScope{name: name, apply: apply})
}

// AddLocalScopeForAlipayHistory assign a local scope to a model
func AddLocalScopeForAlipayHistory(name string, apply func(builder query.Condition)) {
	alipayHistoryLocalScopes = append(alipayHistoryLocalScopes, alipayHistoryScope{name: name, apply: apply})
}

func (m *AlipayHistoryModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range alipayHistoryGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range alipayHistoryLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *AlipayHistoryModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *AlipayHistoryModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}

	return true
}

type AlipayHistory struct {
	Id             int64     `json:"id"`
	UserId         int64     `json:"user_id,omitempty"`
	PaymentId      string    `json:"payment_id,omitempty"`
	ProductId      string    `json:"product_id,omitempty"`
	BuyerId        string    `json:"buyer_id,omitempty"`
	InvoiceAmount  int64     `json:"invoice_amount,omitempty"`
	ReceiptAmount  int64     `json:"receipt_amount,omitempty"`
	BuyerPayAmount int64     `json:"buyer_pay_amount,omitempty"`
	TotalAmount    int64     `json:"total_amount,omitempty"`
	PointAmount    int64     `json:"point_amount,omitempty"`
	TradeNo        string    `json:"trade_no,omitempty"`
	BuyerLogonId   string    `json:"buyer_logon_id,omitempty"`
	Status         int       `json:"status,omitempty"`
	PurchaseAt     time.Time `json:"purchase_at"`
	Note           string    `json:"note"`
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (w AlipayHistory) ToAlipayHistoryN(allows ...string) AlipayHistoryN {
	if len(allows) == 0 {
		return AlipayHistoryN{

			Id:             null.IntFrom(int64(w.Id)),
			UserId:         null.IntFrom(int64(w.UserId)),
			PaymentId:      null.StringFrom(w.PaymentId),
			ProductId:      null.StringFrom(w.ProductId),
			BuyerId:        null.StringFrom(w.BuyerId),
			InvoiceAmount:  null.IntFrom(int64(w.InvoiceAmount)),
			ReceiptAmount:  null.IntFrom(int64(w.ReceiptAmount)),
			BuyerPayAmount: null.IntFrom(int64(w.BuyerPayAmount)),
			TotalAmount:    null.IntFrom(int64(w.TotalAmount)),
			PointAmount:    null.IntFrom(int64(w.PointAmount)),
			TradeNo:        null.StringFrom(w.TradeNo),
			BuyerLogonId:   null.StringFrom(w.BuyerLogonId),
			Status:         null.IntFrom(int64(w.Status)),
			PurchaseAt:     null.TimeFrom(w.PurchaseAt),
			Note:           null.StringFrom(w.Note),
			CreatedAt:      null.TimeFrom(w.CreatedAt),
			UpdatedAt:      null.TimeFrom(w.UpdatedAt),
		}
	}

	res := AlipayHistoryN{}
	for _, al := range allows {
		switch strcase.ToSnake(al) {

		case "id":
			res.Id = null.IntFrom(int64(w.Id))
		case "user_id":
			res.UserId = null.IntFrom(int64(w.UserId))
		case "payment_id":
			res.PaymentId = null.StringFrom(w.PaymentId)
		case "product_id":
			res.ProductId = null.StringFrom(w.ProductId)
		case "buyer_id":
			res.BuyerId = null.StringFrom(w.BuyerId)
		case "invoice_amount":
			res.InvoiceAmount = null.IntFrom(int64(w.InvoiceAmount))
		case "receipt_amount":
			res.ReceiptAmount = null.IntFrom(int64(w.ReceiptAmount))
		case "buyer_pay_amount":
			res.BuyerPayAmount = null.IntFrom(int64(w.BuyerPayAmount))
		case "total_amount":
			res.TotalAmount = null.IntFrom(int64(w.TotalAmount))
		case "point_amount":
			res.PointAmount = null.IntFrom(int64(w.PointAmount))
		case "trade_no":
			res.TradeNo = null.StringFrom(w.TradeNo)
		case "buyer_logon_id":
			res.BuyerLogonId = null.StringFrom(w.BuyerLogonId)
		case "status":
			res.Status = null.IntFrom(int64(w.Status))
		case "purchase_at":
			res.PurchaseAt = null.TimeFrom(w.PurchaseAt)
		case "note":
			res.Note = null.StringFrom(w.Note)
		case "created_at":
			res.CreatedAt = null.TimeFrom(w.CreatedAt)
		case "updated_at":
			res.UpdatedAt = null.TimeFrom(w.UpdatedAt)
		default:
		}
	}

	return res
}

// As convert object to other type
// dst must be a pointer to struct
func (w AlipayHistory) As(dst interface{}) error {
	return query.Copy(w, dst)
}

func (w *AlipayHistoryN) ToAlipayHistory() AlipayHistory {
	return AlipayHistory{

		Id:             w.Id.Int64,
		UserId:         w.UserId.Int64,
		PaymentId:      w.PaymentId.String,
		ProductId:      w.ProductId.String,
		BuyerId:        w.BuyerId.String,
		InvoiceAmount:  w.InvoiceAmount.Int64,
		ReceiptAmount:  w.ReceiptAmount.Int64,
		BuyerPayAmount: w.BuyerPayAmount.Int64,
		TotalAmount:    w.TotalAmount.Int64,
		PointAmount:    w.PointAmount.Int64,
		TradeNo:        w.TradeNo.String,
		BuyerLogonId:   w.BuyerLogonId.String,
		Status:         int(w.Status.Int64),
		PurchaseAt:     w.PurchaseAt.Time,
		Note:           w.Note.String,
		CreatedAt:      w.CreatedAt.Time,
		UpdatedAt:      w.UpdatedAt.Time,
	}
}

// AlipayHistoryModel is a model which encapsulates the operations of the object
type AlipayHistoryModel struct {
	db        *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes  []string

	query query.SQLBuilder
}

var alipayHistoryTableName = "alipay_history"

// AlipayHistoryTable return table name for AlipayHistory
func AlipayHistoryTable() string {
	return alipayHistoryTableName
}

const (
	FieldAlipayHistoryId             = "id"
	FieldAlipayHistoryUserId         = "user_id"
	FieldAlipayHistoryPaymentId      = "payment_id"
	FieldAlipayHistoryProductId      = "product_id"
	FieldAlipayHistoryBuyerId        = "buyer_id"
	FieldAlipayHistoryInvoiceAmount  = "invoice_amount"
	FieldAlipayHistoryReceiptAmount  = "receipt_amount"
	FieldAlipayHistoryBuyerPayAmount = "buyer_pay_amount"
	FieldAlipayHistoryTotalAmount    = "total_amount"
	FieldAlipayHistoryPointAmount    = "point_amount"
	FieldAlipayHistoryTradeNo        = "trade_no"
	FieldAlipayHistoryBuyerLogonId   = "buyer_logon_id"
	FieldAlipayHistoryStatus         = "status"
	FieldAlipayHistoryPurchaseAt     = "purchase_at"
	FieldAlipayHistoryNote           = "note"
	FieldAlipayHistoryCreatedAt      = "created_at"
	FieldAlipayHistoryUpdatedAt      = "updated_at"
)

// AlipayHistoryFields return all fields in AlipayHistory model
func AlipayHistoryFields() []string {
	return []string{
		"id",
		"user_id",
		"payment_id",
		"product_id",
		"buyer_id",
		"invoice_amount",
		"receipt_amount",
		"buyer_pay_amount",
		"total_amount",
		"point_amount",
		"trade_no",
		"buyer_logon_id",
		"status",
		"purchase_at",
		"note",
		"created_at",
		"updated_at",
	}
}

func SetAlipayHistoryTable(tableName string) {
	alipayHistoryTableName = tableName
}

// NewAlipayHistoryModel create a AlipayHistoryModel
func NewAlipayHistoryModel(db query.Database) *AlipayHistoryModel {
	return &AlipayHistoryModel{
		db:                  query.NewDatabaseWrap(db),
		tableName:           alipayHistoryTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes:  make([]string, 0),
		query:               query.Builder(),
	}
}

// GetDB return database instance
func (m *AlipayHistoryModel) GetDB() query.Database {
	return m.db.GetDB()
}

func (m *AlipayHistoryModel) clone() *AlipayHistoryModel {
	return &AlipayHistoryModel{
		db:                  m.db,
		tableName:           m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes:  append([]string{}, m.includeLocalScopes...),
		query:               m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *AlipayHistoryModel) WithoutGlobalScopes(names ...string) *AlipayHistoryModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *AlipayHistoryModel) WithLocalScopes(names ...string) *AlipayHistoryModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Condition add query builder to model
func (m *AlipayHistoryModel) Condition(builder query.SQLBuilder) *AlipayHistoryModel {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *AlipayHistoryModel) Find(ctx context.Context, id int64) (*AlipayHistoryN, error) {
	return m.First(ctx, m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *AlipayHistoryModel) Exists(ctx context.Context, builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(ctx, builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *AlipayHistoryModel) Count(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *AlipayHistoryModel) Paginate(ctx context.Context, page int64, perPage int64, builders ...query.SQLBuilder) ([]AlipayHistoryN, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta{
		PerPage: perPage,
		Page:    page,
	}

	count, err := m.Count(ctx, builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count%perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(ctx, append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *AlipayHistoryModel) Get(ctx context.Context, builders ...query.SQLBuilder) ([]AlipayHistoryN, error) {
	b := m.query.Merge(builders...).Table(m.tableName).AppendCondition(m.applyScope())
	if len(b.GetFields()) == 0 {
		b = b.Select(
			"id",
			"user_id",
			"payment_id",
			"product_id",
			"buyer_id",
			"invoice_amount",
			"receipt_amount",
			"buyer_pay_amount",
			"total_amount",
			"point_amount",
			"trade_no",
			"buyer_logon_id",
			"status",
			"purchase_at",
			"note",
			"created_at",
			"updated_at",
		)
	}

	fields := b.GetFields()
	selectFields := make([]query.Expr, 0)

	for _, f := range fields {
		switch strcase.ToSnake(f.Value) {

		case "id":
			selectFields = append(selectFields, f)
		case "user_id":
			selectFields = append(selectFields, f)
		case "payment_id":
			selectFields = append(selectFields, f)
		case "product_id":
			selectFields = append(selectFields, f)
		case "buyer_id":
			selectFields = append(selectFields, f)
		case "invoice_amount":
			selectFields = append(selectFields, f)
		case "receipt_amount":
			selectFields = append(selectFields, f)
		case "buyer_pay_amount":
			selectFields = append(selectFields, f)
		case "total_amount":
			selectFields = append(selectFields, f)
		case "point_amount":
			selectFields = append(selectFields, f)
		case "trade_no":
			selectFields = append(selectFields, f)
		case "buyer_logon_id":
			selectFields = append(selectFields, f)
		case "status":
			selectFields = append(selectFields, f)
		case "purchase_at":
			selectFields = append(selectFields, f)
		case "note":
			selectFields = append(selectFields, f)
		case "created_at":
			selectFields = append(selectFields, f)
		case "updated_at":
			selectFields = append(selectFields, f)
		}
	}

	var createScanVar = func(fields []query.Expr) (*AlipayHistoryN, []interface{}) {
		var alipayHistoryVar AlipayHistoryN
		scanFields := make([]interface{}, 0)

		for _, f := range fields {
			switch strcase.ToSnake(f.Value) {

			case "id":
				scanFields = append(scanFields, &alipayHistoryVar.Id)
			case "user_id":
				scanFields = append(scanFields, &alipayHistoryVar.UserId)
			case "payment_id":
				scanFields = append(scanFields, &alipayHistoryVar.PaymentId)
			case "product_id":
				scanFields = append(scanFields, &alipayHistoryVar.ProductId)
			case "buyer_id":
				scanFields = append(scanFields, &alipayHistoryVar.BuyerId)
			case "invoice_amount":
				scanFields = append(scanFields, &alipayHistoryVar.InvoiceAmount)
			case "receipt_amount":
				scanFields = append(scanFields, &alipayHistoryVar.ReceiptAmount)
			case "buyer_pay_amount":
				scanFields = append(scanFields, &alipayHistoryVar.BuyerPayAmount)
			case "total_amount":
				scanFields = append(scanFields, &alipayHistoryVar.TotalAmount)
			case "point_amount":
				scanFields = append(scanFields, &alipayHistoryVar.PointAmount)
			case "trade_no":
				scanFields = append(scanFields, &alipayHistoryVar.TradeNo)
			case "buyer_logon_id":
				scanFields = append(scanFields, &alipayHistoryVar.BuyerLogonId)
			case "status":
				scanFields = append(scanFields, &alipayHistoryVar.Status)
			case "purchase_at":
				scanFields = append(scanFields, &alipayHistoryVar.PurchaseAt)
			case "note":
				scanFields = append(scanFields, &alipayHistoryVar.Note)
			case "created_at":
				scanFields = append(scanFields, &alipayHistoryVar.CreatedAt)
			case "updated_at":
				scanFields = append(scanFields, &alipayHistoryVar.UpdatedAt)
			}
		}

		return &alipayHistoryVar, scanFields
	}

	sqlStr, params := b.Fields(selectFields...).ResolveQuery()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	alipayHistorys := make([]AlipayHistoryN, 0)
	for rows.Next() {
		alipayHistoryReal, scanFields := createScanVar(fields)
		if err := rows.Scan(scanFields...); err != nil {
			return nil, err
		}

		alipayHistoryReal.original = &alipayHistoryOriginal{}
		_ = query.Copy(alipayHistoryReal, alipayHistoryReal.original)

		alipayHistoryReal.SetModel(m)
		alipayHistorys = append(alipayHistorys, *alipayHistoryReal)
	}

	return alipayHistorys, nil
}

// First return first result for given query
func (m *AlipayHistoryModel) First(ctx context.Context, builders ...query.SQLBuilder) (*AlipayHistoryN, error) {
	res, err := m.Get(ctx, append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, query.ErrNoResult
	}

	return &res[0], nil
}

// Create save a new alipay_history to database
func (m *AlipayHistoryModel) Create(ctx context.Context, kv query.KV) (int64, error) {

	if _, ok := kv["created_at"]; !ok {
		kv["created_at"] = time.Now()
	}

	if _, ok := kv["updated_at"]; !ok {
		kv["updated_at"] = time.Now()
	}

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all alipay_historys to database
func (m *AlipayHistoryModel) SaveAll(ctx context.Context, alipayHistorys []AlipayHistoryN) ([]int64, error) {
	ids := make([]int64, 0)
	for _, alipayHistory := range alipayHistorys {
		id, err := m.Save(ctx, alipayHistory)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a alipay_history to database
func (m *AlipayHistoryModel) Save(ctx context.Context, alipayHistory AlipayHistoryN, onlyFields ...string) (int64, error) {
	return m.Create(ctx, alipayHistory.StaledKV(onlyFields...))
}

// SaveOrUpdate save a new alipay_history or update it when it has a id > 0
func (m *AlipayHistoryModel) SaveOrUpdate(ctx context.Context, alipayHistory AlipayHistoryN, onlyFields ...string) (id int64, updated bool, err error) {
	if alipayHistory.Id.Int64 > 0 {
		_, _err := m.UpdateById(ctx, alipayHistory.Id.Int64, alipayHistory, onlyFields...)
		return alipayHistory.Id.Int64, true, _err
	}

	_id, _err := m.Save(ctx, alipayHistory, onlyFields...)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *AlipayHistoryModel) UpdateFields(ctx context.Context, kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	kv["updated_at"] = time.Now()

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *AlipayHistoryModel) Update(ctx context.Context, builder query.SQLBuilder, alipayHistory AlipayHistoryN, onlyFields ...string) (int64, error) {
	return m.UpdateFields(ctx, alipayHistory.StaledKV(onlyFields...), builder)
}

// UpdateById update a model by id
func (m *AlipayHistoryModel) UpdateById(ctx context.Context, id int64, alipayHistory AlipayHistoryN, onlyFields ...string) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).UpdateFields(ctx, alipayHistory.StaledKV(onlyFields...))
}

// Delete remove a model
func (m *AlipayHistoryModel) Delete(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()

}

// DeleteById remove a model by id
func (m *AlipayHistoryModel) DeleteById(ctx context.Context, id int64) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).Delete(ctx)
}
